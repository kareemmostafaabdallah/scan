name: Odd Endpoints Detector & Discord Alert

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'Target domain or base URL (e.g. https://example.com)'
        required: true
        default: 'https://example.com'

jobs:
  detect:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up tools
        run: |
          sudo apt update -y
          sudo apt install -y jq curl httpx ffuf

      - name: Initialize
        run: |
          set -euo pipefail
          mkdir -p odd-endpoints-output
          echo "TARGET_URL=${{ github.event.inputs.target }}" >> $GITHUB_ENV
          echo "KEYWORDS_RAW=admin,login,debug,backup,wp-admin,config,upload,dashboard,portal" >> $GITHUB_ENV
          echo "STATUS_FILTER=401,403,500,502,503,302" >> $GITHUB_ENV
          echo "MAX_PATH_LENGTH=120" >> $GITHUB_ENV

      - name: Discover endpoints using ffuf
        run: |
          set -euo pipefail
          WORDLIST=/usr/share/wordlists/dirb/common.txt
          OUTPUT=odd-endpoints-output/all_paths_raw.txt

          echo "[+] Starting ffuf scan on $TARGET_URL"
          ffuf -u "$TARGET_URL/FUZZ" -w "$WORDLIST" -t 50 -of csv -o ffuf_results.csv || true
          cut -d',' -f1 ffuf_results.csv | grep -E -v '^url$' > "$OUTPUT"
          sort -u "$OUTPUT" -o "$OUTPUT"
          echo "[+] Saved discovered paths: $(wc -l < "$OUTPUT")"

      - name: Probe candidate endpoints with httpx and classify suspicious ones
        run: |
          set -euo pipefail
          mkdir -p odd-endpoints-output/probe
          INPUT=odd-endpoints-output/all_paths_raw.txt
          if [ ! -s "$INPUT" ]; then
            printf "/admin\n/login\n/wp-admin\n/config\n/.env\n" > "$INPUT"
          fi

          IFS=',' read -r -a KW_ARR <<< "${KEYWORDS_RAW:-admin,login,debug,backup,wp-admin,config,upload,dashboard,portal}"
          RESULT_FILE=odd-endpoints-output/probe/probe_results.json
          : > "$RESULT_FILE"

          while IFS= read -r path || [ -n "$path" ]; do
            p="${path#/}"
            p="/${p}"
            url="${TARGET_URL}${p}"

            if command -v httpx >/dev/null 2>&1; then
              httpx_out=$(echo "$url" | httpx -silent -status-code -title -content-length -ip -threads 5 2>/dev/null || echo "")
              status=$(echo "$httpx_out" | awk '{print $2}' | head -n1 || echo "")
              length=$(echo "$httpx_out" | awk '{print $4}' | head -n1 || echo "")
            else
              status=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 10 "$url" 2>/dev/null || echo "")
              length=$(curl -s -L --max-time 10 "$url" 2>/dev/null | wc -c || echo "")
            fi

            hdrs=$(curl -s -I -L --max-time 10 "$url" 2>/dev/null || echo "")
            server_hdr=$(echo "$hdrs" | grep -i '^Server:' || true)
            x_debug=$(echo "$hdrs" | grep -Ei 'x-debug|x-powered-by|x-info' || true)

            reasons_arr=()
            if [ -n "$status" ]; then
              for sc in $(echo "${STATUS_FILTER:-401,403,500,502,503,302}" | tr ',' ' '); do
                if [ "$status" = "$sc" ]; then
                  reasons_arr+=("status=$status")
                fi
              done
            fi

            lowpath=$(echo "$p" | tr '[:upper:]' '[:lower:]')
            for kw in "${KW_ARR[@]}"; do
              kw_trim=$(echo "$kw" | sed 's/ //g')
              if [ -n "$kw_trim" ] && echo "$lowpath" | grep -q "$kw_trim"; then
                reasons_arr+=("keyword=$kw_trim")
              fi
            done

            plen=$(echo -n "$p" | wc -c)
            if [ "$plen" -ge "${MAX_PATH_LENGTH:-120}" ]; then
              reasons_arr+=("long_path=${plen}")
            fi

            if [ -n "$x_debug" ]; then
              reasons_arr+=("debug_header")
            fi

            if echo "$p" | grep -E '\.env|\.git|backup|\.sql|\.zip|credentials' >/dev/null 2>&1; then
              reasons_arr+=("sensitive_filename")
            fi

            if [ "${#reasons_arr[@]}" -gt 0 ]; then
              jq -n \
                --arg url "$url" \
                --arg status "${status:-}" \
                --arg length "${length:-}" \
                --arg server "$(echo "$server_hdr" | tr '\n' ' ' | sed 's/"/\\"/g')" \
                --argjson reasons "$(printf '%s\n' "${reasons_arr[@]}" | jq -R . | jq -s .)" \
                '{url:$url, status:$status, length:$length, server:$server, reasons:$reasons}' >> "$RESULT_FILE"
            fi

          done < "$INPUT"

          echo "[+] Suspicious endpoints written to $RESULT_FILE"

      - name: Send results to Discord
        if: always()
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          set -euo pipefail
          FILE=odd-endpoints-output/probe/probe_results.json
          if [ ! -s "$FILE" ]; then
            echo "No suspicious endpoints found."
            exit 0
          fi

          jq -c '.' "$FILE" | while read -r line; do
            url=$(echo "$line" | jq -r '.url')
            reasons=$(echo "$line" | jq -r '.reasons | join(", ")')
            status=$(echo "$line" | jq -r '.status')
            msg="ðŸ•µï¸ Odd Endpoint Found:\nURL: $url\nStatus: $status\nReasons: $reasons"
            curl -H "Content-Type: application/json" \
                 -d "{\"content\":\"$msg\"}" \
                 "$DISCORD_WEBHOOK"
          done
