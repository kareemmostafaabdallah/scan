name: odd-endpoints-detector

on:
  workflow_dispatch:
    inputs:
      domain:
        description: "Target domain (example.com or https://example.com)"
        required: true
        default: "example.com"
      wordlist_url:
        description: "Wordlist URL for small ffuf checks"
        required: false
        default: "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/raft-small-words.txt"
      threads:
        description: "ffuf/httpx threads"
        required: false
        default: "20"
      follow_redirects:
        description: "ffuf follow redirects (true/false)"
        required: false
        default: "false"
      status_filter:
        description: "Comma separated suspicious status codes"
        required: false
        default: "401,403,500,502,503,302"
      keyword_list:
        description: "Comma separated suspicious keywords"
        required: false
        default: "admin,login,debug,backup,wp-admin,config,upload,portal,dashboard"
      max_path_length:
        description: "Path length threshold to consider suspicious"
        required: false
        default: "120"

jobs:
  detect:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate webhook secret
        run: |
          if [ -z "${{ secrets.DISCORD_WEBHOOK }}" ]; then
            echo "::warning::DISCORD_WEBHOOK secret not set. Discord notifications will be skipped."
          else
            echo "DISCORD_WEBHOOK=${{ secrets.DISCORD_WEBHOOK }}" >> $GITHUB_ENV
          fi

      - name: Install dependencies and tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl git build-essential wget unzip ca-certificates || true
          # ensure GOPATH/bin available
          echo "$HOME/go/bin" >> $GITHUB_PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          export PATH=$PATH:$HOME/go/bin:$HOME/.local/bin
          export GOBIN=${GOBIN:-$HOME/.local/bin}
          mkdir -p "$GOBIN"
          # install tools (best-effort)
          /usr/bin/env bash -lc "GOBIN=$GOBIN go install github.com/projectdiscovery/httpx/cmd/httpx@latest" || true
          /usr/bin/env bash -lc "GOBIN=$GOBIN go install github.com/lc/gau/v2/cmd/gau@latest" || true
          /usr/bin/env bash -lc "GOBIN=$GOBIN go install github.com/ffuf/ffuf@latest" || true
          jq --version || true
          mkdir -p odd-endpoints-output tmp wordlists

      - name: Prepare environment variables
        run: |
          RAW="${{ github.event.inputs.domain }}"
          if echo "$RAW" | grep -qE '^https?://'; then
            HOST=$(echo "$RAW" | sed -E 's#^https?://##' | sed -E 's#/$##')
            echo "TARGET_URL=https://$HOST" >> $GITHUB_ENV
            echo "TARGET_HOST=$HOST" >> $GITHUB_ENV
          else
            HOST="$RAW"
            echo "TARGET_URL=https://$HOST" >> $GITHUB_ENV
            echo "TARGET_HOST=$HOST" >> $GITHUB_ENV
          fi
          echo "THREADS=${{ github.event.inputs.threads }}" >> $GITHUB_ENV
          echo "WORDLIST_URL=${{ github.event.inputs.wordlist_url }}" >> $GITHUB_ENV
          echo "FOLLOW_FLAG=${{ github.event.inputs.follow_redirects }}" >> $GITHUB_ENV
          echo "STATUS_FILTER=${{ github.event.inputs.status_filter }}" >> $GITHUB_ENV
          echo "KEYWORDS_RAW=${{ github.event.inputs.keyword_list }}" >> $GITHUB_ENV
          echo "MAX_PATH_LENGTH=${{ github.event.inputs.max_path_length }}" >> $GITHUB_ENV

      - name: Download small wordlist
        run: |
          WL=wordlists/wordlist.txt
          if [ -n "$WORDLIST_URL" ]; then
            curl -fsSL "$WORDLIST_URL" -o "$WL" || true
          fi
          if [ ! -s "$WL" ]; then
            printf "admin\nlogin\nbackup\nconfig\n.git\n.env\n" > "$WL"
          fi
          sort -u "$WL" -o "$WL" || true
          echo "wordlist lines: $(wc -l < "$WL" || echo 0)"

      - name: Gather paths (gau + quick ffuf poke)
        run: |
          set -euo pipefail
          mkdir -p odd-endpoints-output/gau odd-endpoints-output/ffuf
          if command -v gau >/dev/null 2>&1; then
            gau --subs "$TARGET_HOST" 2>/dev/null | sed 's#https\?://[^/]*##' | sort -u > odd-endpoints-output/gau/gau_paths.txt || true
          else
            touch odd-endpoints-output/gau/gau_paths.txt
          fi
          FF_THREADS="${THREADS:-20}"
          FF_TIMEOUT="${{ github.event.inputs.timeout || '8' }}"
          if command -v ffuf >/dev/null 2>&1; then
            ffuf -u "${TARGET_URL}/FUZZ" -w wordlists/wordlist.txt -t "${FF_THREADS}" -timeout "${FF_TIMEOUT}" -of json -o odd-endpoints-output/ffuf/ffuf_root.json || true
            jq -r '.results[]?.url' odd-endpoints-output/ffuf/ffuf_root.json 2>/dev/null | sed 's#https\?://[^/]*##' | sort -u > odd-endpoints-output/ffuf/ffuf_root_paths.txt || true
          else
            touch odd-endpoints-output/ffuf/ffuf_root_paths.txt
          fi
          cat odd-endpoints-output/gau/gau_paths.txt odd-endpoints-output/ffuf/ffuf_root_paths.txt | sed '/^\s*$/d' | sort -u > odd-endpoints-output/all_paths_raw.txt || true
          echo "Total candidate paths: $(wc -l < odd-endpoints-output/all_paths_raw.txt || echo 0)"

      - name: Probe candidate endpoints with httpx and classify suspicious ones
        run: |
          set -euo pipefail
          mkdir -p odd-endpoints-output/probe
          INPUT=odd-endpoints-output/all_paths_raw.txt
          if [ ! -s "$INPUT" ]; then
            printf "/admin\n/login\n/wp-admin\n/config\n/.env\n" > "$INPUT"
          fi
          IFS=',' read -r -a KW_ARR <<< "${KEYWORDS_RAW:-admin,login,debug,backup,wp-admin,config,upload,dashboard,portal}"
          : > odd-endpoints-output/probe/probe_results.json
          while IFS= read -r path || [ -n "$path" ]; do
            # normalize leading slash
            p="${path#/}"
            p="/$p"
            url="${TARGET_URL}${p}"
            # attempt httpx first, fallback to curl headers if missing
            if command -v httpx >/dev/null 2>&1; then
              # httpx -json would be nicer but keep simple parsing
              out=$(echo "$url" | httpx -silent -status-code -title -content-length -ip -threads 10 2>/dev/null || echo "")
            else
              out=$(curl -s -I -L --max-time 10 "$url" 2>/dev/null || echo "")
            fi
            # extract status and length safely
            status=$(echo "$out" | awk '{print $2}' | head -n1 || echo "")
            length=$(echo "$out" | awk '{print $3}' | head -n1 || echo "")
            # headers snapshot (fallback)
            hdrs=$(curl -s -I -L --max-time 10 "$url" 2>/dev/null || echo "")
            server_hdr=$(echo "$hdrs" | grep -i '^Server:' || true)
            x_debug=$(echo "$hdrs" | grep -i -E 'x-debug|x-powered-by|x-info' || true)
            reasons=()
            if [ -n "$status" ]; then
              for sc in $(echo "${STATUS_FILTER:-401,403,500,502,503,302}" | tr ',' ' '); do
                if [ "$status" = "$sc" ]; then
                  reasons+=("status=$status")
                fi
              done
            fi
            lowpath=$(echo "$p" | tr '[:upper:]' '[:lower:]')
            for kw in "${KW_ARR[@]}"; do
              kw_trim=$(echo "$kw" | sed 's/ //g')
              if [ -n "$kw_trim" ] && echo "$lowpath" | grep -q "$kw_trim"; then
                reasons+=("keyword=$kw_trim")
              fi
            done
            plen=$(echo -n "$p" | wc -c)
            if [ "$plen" -ge "${MAX_PATH_LENGTH:-120}" ]; then
              reasons+=("long_path=${plen}")
            fi
            if [ -n "$x_debug" ]; then
              reasons+=("debug_header")
            fi
            if echo "$p" | grep -E '\.env|\.git|backup|\.sql|\.zip|credentials' >/dev/null 2>&1; then
              reasons+=("sensitive_filename")
            fi
            if [ "${#reasons[@]}" -gt 0 ]; then
              # build JSON safely using jq; append as NDJSON (one JSON per line)
              reasons_json=$(printf '%s\n' "${reasons[@]}" | jq -R . | jq -s .)
              jq -n --arg url "$url" --arg status "$status" --arg length "$length" --arg server "$(echo "$server_hdr" | tr '\n' ' ')" --argjson reasons "$reasons_json" \
                '{url:$url, status:$status, length:$length, server:$server, reasons:$reasons}' >> odd-endpoints-output/probe/probe_results.json
            fi
          done < "$INPUT"
          if [ -s odd-endpoints-output/probe/probe_results.json ]; then
            echo "Suspicious endpoints found: $(wc -l < odd-endpoints-output/probe/probe_results.json || echo 0)"
          else
            echo "Suspicious endpoints found: 0"
          fi

      - name: Aggregate and prepare summary
        run: |
          mkdir -p odd-endpoints-output/report
          if [ -s odd-endpoints-output/probe/probe_results.json ]; then
            jq -s '.' odd-endpoints-output/probe/probe_results.json > odd-endpoints-output/report/odd_endpoints.json || true
            jq -r '.[] | "- " + .url + " [" + (.reasons|join(", ")) + "]"' odd-endpoints-output/report/odd_endpoints.json > odd-endpoints-output/report/summary.txt || true
          else
            echo "No suspicious endpoints found." > odd-endpoints-output/report/summary.txt
          fi
          sed -n '1,200p' odd-endpoints-output/report/summary.txt

      - name: Notify Discord if webhook configured
        if: env.DISCORD_WEBHOOK != ''
        run: |
          if [ -s odd-endpoints-output/report/odd_endpoints.json ]; then
            TITLE="Odd endpoints detected for ${{ github.event.inputs.domain }}"
            BODY_TEXT=$(jq -r '.[] | "- " + .url + " [" + (.reasons|join(", ")) + "]"' odd-endpoints-output/report/odd_endpoints.json | sed 's/"/\\"/g' || true)
            # build payload safely to a file
            jq -n --arg content "$TITLE\n\nSummary:\n$BODY_TEXT" --arg title "Odd endpoints summary" '{content:$content, embeds:[{title:$title, description:$content}]}' > odd-endpoints-output/report/payload.json
            # post
            curl -s -H "Content-Type: application/json" -d @odd-endpoints-output/report/payload.json "${{ env.DISCORD_WEBHOOK }}" || true
          else
            jq -n --arg c "Scan finished for ${{ github.event.inputs.domain }} â€” None found." '{content:$c}' > odd-endpoints-output/report/payload.json
            curl -s -H "Content-Type: application/json" -d @odd-endpoints-output/report/payload.json "${{ env.DISCORD_WEBHOOK }}" || true
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: odd-endpoints-${{ github.run_id }}-${{ github.event.inputs.domain }}
          path: |
            odd-endpoints-output/**
